
MULTI-THREADING IN JAVA
-----------------------


THREAD CLASS METHODS
--------------------

PUBLIC VOID START(): START A THREAD BY CALLING ITS RUN() METHOD
PUBLIC VOID RUN(): ENTRY POINT FOR THE THREAD
PUBLIC FINAL VOID SETNAME(STRING NAME): SET THE NAME OF THE THREAD
PUBLIC FINAL VOID SETPRIORITY(INT PRIORITY): TO SET THE PRIORITY OF THE THREAD
PUBLIC FINAL VOID SETDAEMON(BOOLEAN ON): A PARAMETER OF TRUE DENOTES THIS THREAD AS A DAEMON THREAD.
VOID JOIN(LONG MILLISEC): WAIT FOR A THREAD TO TERMINATE. THIS METHOD WHEN CALLED FROM THE PARENT THREAD MAKES PARENT THREAD WAIT TILL CHILD THREAD TERMINATES. THE CURRENT THREAD INVOKES THIS METHOD ON A SECOND THREAD, CAUSING THE CURRENT THREAD TO BLOCK UNTIL THE SECOND THREAD TERMINATES OR THE SPECIFIED NUMBER OF MILLISECONDS PASSES.
PUBLIC VOID INTERRUPT(): INTERRUPTS THIS THREAD, CAUSING IT TO CONTINUE EXECUTION IF IT WAS BLOCKED FOR ANY REASON.
PUBLIC FINAL BOOLEAN ISALIVE(): DETERMINE IF A THREAD IS STILL RUNNING


THE FOLLOWING METHODS IN THE THREAD CLASS ARE STATIC. INVOKING ONE OF THE STATIC METHODS PERFORMS THE OPERATION ON THE CURRENTLY RUNNING THREAD.

PUBLIC STATIC VOID YIELD(): CAUSES THE CURRENTLY RUNNING THREAD TO YIELD TO ANY OTHER THREADS OF THE SAME PRIORITY THAT ARE WAITING TO BE SCHEDULED.
PUBLIC STATIC VOID SLEEP(LONG MILLISEC): CAUSES THE CURRENTLY RUNNING THREAD TO BLOCK FOR AT LEAST THE SPECIFIED NUMBER OF MILLISECONDS.
PUBLIC STATIC BOOLEAN HOLDSLOCK(OBJECT X): RETURNS TRUE IF THE CURRENT THREAD HOLDS THE LOCK ON THE GIVEN OBJECT.
PUBLIC STATIC THREAD CURRENTTHREAD(): RETURNS A REFERENCE TO THE CURRENTLY RUNNING THREAD, WHICH IS THE THREAD THAT INVOKES THIS METHOD.
PUBLIC STATIC VOID DUMPSTACK(): PRINTS THE STACK TRACE FOR THE CURRENTLY RUNNING THREAD, WHICH IS USEFUL WHEN DEBUGGING A MULTITHREADED APPLICATION.
GETNAME(): IT IS USED FOR OBTAINING A THREAD’S NAME
VOID GETPRIORITY(): OBTAIN A THREAD’S PRIORITY


MINPRIORITY, NORMPRIORITY OR MAXPRIORITY.


THERE ARE SOME METHODS THAT CAN BE USE BY THE THREADS TO COMMUNICATE WITH EACH OTHER. THEY ARE AS FOLLOWING,

WAIT(): TELLS THE CALLING THREAD TO GIVE UP THE MONITOR AND GO TO SLEEP UNTIL SOME OTHER THREAD ENTERS THE SAME MONITOR AND CALLS NOTIFY().
NOTIFY(): WAKES UP THE FIRST THREAD THAT CALLED WAIT() ON THE SAME OBJECT.
NOTIFYALL(): WAKES UP ALL THE THREADS THAT CALLED WAIT() ON THE SAME OBJECT. THE HIGHEST PRIORITY THREAD WILL RUN FIRST.


JAVA THREAD PRIORITIES ARE IN THE RANGE BETWEEN MINPRIORITY (A CONSTANT OF 1) AND MAXPRIORITY (A CONSTANT OF 10). BY DEFAULT, EVERY THREAD IS GIVEN PRIORITY NORMPRIORITY (A CONSTANT OF 5). THREADS WITH HIGHER PRIORITY ARE MORE IMPORTANT TO A PROGRAM AND SHOULD BE ALLOCATED PROCESSOR TIME BEFORE LOWER-PRIORITY THREADS. HOWEVER, THREAD PRIORITIES CANNOT GUARANTEE THE ORDER IN WHICH THREADS EXECUTE AND VERY MUCH PLATFORM DEPENDENT.



THREAD SYNCHRONIZATION

WHEN TWO OR MORE THREADS NEED ACCESS TO A SHARED RESOURCE THERE SHOULD BE SOME WAY THAT THE RESOURCE WILL BE USED ONLY BY ONE RESOURCE AT A TIME. THE PROCESS TO ACHIEVE THIS IS CALLED SYNCHRONIZATION. ONCE A THREAD IS INSIDE A SYNCHRONIZED METHOD, NO OTHER THREAD CAN CALL ANY OTHER SYNCHRONIZED METHOD ON THE SAME OBJECT. TO UNDERSTAND SYNCHRONIZATION JAVA HAS A CONCEPT OF MONITOR. MONITOR CAN BE THOUGHT OF AS A BOX WHICH CAN HOLD ONLY ONE THREAD. ONCE A THREAD ENTERS THE MONITOR ALL THE OTHER THREADS HAVE TO WAIT UNTIL THAT THREAD EXITS THE MONITOR.

INTER-THREAD COMMUNICATION
INTER THREAD COMMUNICATION IS IMPORTANT WHEN YOU DEVELOP AN APPLICATION WHERE TWO OR MORE THREADS EXCHANGE SOME INFORMATION.
PUBLIC VOID WAIT(): CAUSES THE CURRENT THREAD TO WAIT UNTIL ANOTHER THREAD INVOKES THE NOTIFY().
PUBLIC VOID NOTIFY(): WAKES UP A SINGLE THREAD THAT IS WAITING ON THIS OBJECT'S MONITOR.
PUBLIC VOID NOTIFYALL(): WAKES UP ALL THE THREADS THAT CALLED WAIT( ) ON THE SAME OBJECT.
THESE METHODS HAVE BEEN IMPLEMENTED AS FINAL METHODS IN OBJECT, SO THEY ARE AVAILABLE IN ALL THE CLASSES. ALL 3 METHODS CAN BE CALLED ONLY FROM WITHIN A SYNCHRONIZED CONTEXT.
THREAD DEADLOCK
DEADLOCK DESCRIBES A SITUATION WHERE TWO OR MORE THREADS ARE BLOCKED FOREVER, WAITING FOR EACH OTHER. DEADLOCK OCCURS WHEN MULTIPLE THREADS NEED THE SAME LOCKS BUT OBTAIN THEM IN DIFFERENT ORDER. A JAVA MULTITHREADED PROGRAM MAY SUFFER FROM THE DEADLOCK CONDITION BECAUSE THE SYNCHRONIZED KEYWORD CAUSES THE EXECUTING THREAD TO BLOCK WHILE WAITING FOR THE LOCK, OR MONITOR, ASSOCIATED WITH THE SPECIFIED OBJECT.

THREAD CONTROL

CORE JAVA PROVIDES A COMPLETE CONTROL OVER MULTITHREADED PROGRAM. YOU CAN DEVELOP A MULTITHREADED PROGRAM WHICH CAN BE SUSPENDED, RESUMED OR STOPPED COMPLETELY BASED ON YOUR REQUIREMENTS. THERE ARE VARIOUS STATIC METHODS WHICH YOU CAN USE ON THREAD OBJECTS TO CONTROL THEIR BEHAVIOR.
PUBLIC VOID SUSPEND(): THIS METHOD PUTS A THREAD IN SUSPENDED STATE AND CAN BE RESUMED USING RESUME() METHOD.
PUBLIC VOID STOP(): THIS METHOD STOPS A THREAD COMPLETELY.
PUBLIC VOID RESUME(): THIS METHOD RESUMES A THREAD WHICH WAS SUSPENDED USING SUSPEND() METHOD.
PUBLIC VOID WAIT(): CAUSES THE CURRENT THREAD TO WAIT UNTIL ANOTHER THREAD INVOKES THE NOTIFY().
PUBLIC VOID NOTIFY(): WAKES UP A SINGLE THREAD THAT IS WAITING ON THIS OBJECT'S MONITOR.
BE AWARE THAT LATEST VERSIONS OF JAVA HAS DEPRECATED THE USAGE OF SUSPEND(), RESUME() AND STOP() METHODS AND SO YOU NEED TO USE AVAILABLE ALTERNATIVES.
THREAD LIFE CYCLE AND THREAD SCHEDULING
THE START METHOD CREATES THE SYSTEM RESOURCES, NECESSARY TO RUN THE THREAD, SCHEDULES THE THREAD TO RUN, AND CALLS THE THREAD’S RUN METHOD.
A THREAD BECOMES “NOT RUNNABLE” WHEN ONE OF THESE EVENTS OCCURS:
IF SLEEP METHOD IS INVOKED.
THE THREAD CALLS THE WAIT METHOD.
THE THREAD IS BLOCKING ON I/O.
A THREAD DIES NATURALLY WHEN THE RUN METHOD EXITS.

THREAD SCHEDULING
EXECUTION OF MULTIPLE THREADS ON A SINGLE CPU, IN SOME ORDER, IS CALLED SCHEDULING.
IN GENERAL, THE RUNNABLE THREAD WITH THE HIGHEST PRIORITY IS ACTIVE (RUNNING)
JAVA IS PRIORITY-PREEMPTIVE
IF A HIGH-PRIORITY THREAD WAKES UP, AND A LOW-PRIORITY THREAD IS RUNNING
THEN THE HIGH-PRIORITY THREAD GETS TO RUN IMMEDIATELY
ALLOWS ON-DEMAND PROCESSING
EFFICIENT USE OF CPU
TYPES OF SCHEDULING
WAITING AND NOTIFYING
WAITING [WAIT()] AND NOTIFYING [NOTIFY(), NOTIFYALL()] PROVIDES MEANS OF COMMUNICATION BETWEEN THREADS THAT SYNCHRONIZE ON THE SAME OBJECT.
WAIT(): WHEN WAIT() METHOD IS INVOKED ON AN OBJECT, THE THREAD EXECUTING THAT CODE GIVES UP ITS LOCK ON THE OBJECT IMMEDIATELY AND MOVES THE THREAD TO THE WAIT STATE.
NOTIFY(): THIS WAKES UP THREADS THAT CALLED WAIT() ON THE SAME OBJECT AND MOVES THE THREAD TO READY STATE.
NOTIFYALL(): THIS WAKES UP ALL THE THREADS THAT CALLED WAIT() ON THE SAME OBJECT.
RUNNING AND YIELDING
YIELD() IS USED TO GIVE THE OTHER THREADS OF THE SAME PRIORITY A CHANCE TO EXECUTE I.E. CAUSES CURRENT RUNNING THREAD TO MOVE TO RUNNABLE STATE.
SLEEPING AND WAKING UP
NSLEEP() IS USED TO PAUSE A THREAD FOR A SPECIFIED PERIOD OF TIME I.E. MOVES THE CURRENT RUNNING THREAD TO SLEEP STATE FOR A SPECIFIED AMOUNT OF TIME, BEFORE MOVING IT TO RUNNABLE STATE. THREAD.SLEEP(NO. OF MILLISECONDS);

THREAD PRIORITY
WHEN A JAVA THREAD IS CREATED, IT INHERITS ITS PRIORITY FROM THE THREAD THAT CREATED IT.
YOU CAN MODIFY A THREAD’S PRIORITY AT ANY TIME AFTER ITS CREATION USING THE SETPRIORITY() METHOD.
THREAD PRIORITIES ARE INTEGERS RANGING BETWEEN MINPRIORITY (1) AND MAXPRIORITY (10) . THE HIGHER THE INTEGER, THE HIGHER THE PRIORITY.NORMALLY THE THREAD PRIORITY WILL BE 5.
BLOCKING THREADS
WHEN READING FROM A STREAM, IF INPUT IS NOT AVAILABLE, THE THREAD WILL BLOCK
THREAD IS SUSPENDED (“BLOCKED”) UNTIL I/O IS AVAILABLE
ALLOWS OTHER THREADS TO AUTOMATICALLY ACTIVATE
WHEN I/O AVAILABLE, THREAD WAKES BACK UP AGAIN
BECOMES “RUNNABLE” I.E. GETS INTO READY STATE
GROUPING THREADS
THREAD GROUPS PROVIDE A MECHANISM FOR COLLECTING MULTIPLE THREADS INTO A SINGLE OBJECT AND MANIPULATING THOSE THREADS ALL AT ONCE, RATHER THAN INDIVIDUALLY.
TO PUT A NEW THREAD IN A THREAD GROUP THE GROUP MUST
BE EXPLICITLY SPECIFIED WHEN THE THREAD IS CREATED
– PUBLIC THREAD(THREADGROUP GROUP, RUNNABLE RUNNABLE)
– PUBLIC THREAD(THREADGROUP GROUP, STRING NAME)
– PUBLIC THREAD(THREADGROUP GROUP, RUNNABLE RUNNABLE, STRING NAME)
A THREAD CAN NOT BE MOVED TO A NEW GROUP AFTER THE THREAD HAS BEEN CREATED.
WHEN A JAVA APPLICATION FIRST STARTS UP, THE JAVA RUNTIME SYSTEM CREATES A THREADGROUP NAMED MAIN.
JAVA THREAD GROUPS ARE IMPLEMENTED BY THE JAVA.LANG.THREADGROUP CLASS.

DAEMON THREAD
DAEMON THREAD IS A LOW PRIORITY THREAD (IN CONTEXT OF JVM) THAT RUNS IN BACKGROUND TO PERFORM TASKS SUCH AS GARBAGE COLLECTION (GC) ETC., THEY DO NOT PREVENT THE JVM FROM EXITING (EVEN IF THE DAEMON THREAD ITSELF IS RUNNING) WHEN ALL THE USER THREADS (NON-DAEMON THREADS) FINISH THEIR EXECUTION. JVM TERMINATES ITSELF WHEN ALL USER THREADS (NON-DAEMON THREADS) FINISH THEIR EXECUTION, JVM DOES NOT CARE WHETHER DAEMON THREAD IS RUNNING OR NOT, IF JVM FINDS RUNNING DAEMON THREAD (UPON COMPLETION OF USER THREADS), IT TERMINATES THE THREAD AND AFTER THAT SHUTDOWN ITSELF.
1 # A NEWLY CREATED THREAD INHERITS THE DAEMON STATUS OF ITS PARENT. THAT’S THE REASON ALL THREADS CREATED INSIDE MAIN METHOD (CHILD THREADS OF MAIN THREAD) ARE NON-DAEMON BY DEFAULT, BECAUSE MAIN THREAD IS NON-DAEMON.
2 # METHODS OF THREAD CLASS THAT ARE RELATED TO DAEMON THREADS AS FOLLOWING,
PUBLIC VOID SETDAEMON(BOOLEAN STATUS): THIS METHOD IS USED FOR MAKING A USER THREAD TO DAEMON THREAD OR VICE VERSA. FOR EXAMPLE IF I HAVE A USER THREAD T THEN T.SETDAEMON(TRUE) WOULD MAKE IT DAEMON THREAD. ON THE OTHER HAND IF I HAVE A DAEMON THREAD TD THEN BY CALLING TD.SETDAEMON(FALSE) WOULD MAKE IT NORMAL THREAD(USER THREAD/NON-DAEMON THREAD).
PUBLIC BOOLEAN ISDAEMON(): THIS METHOD IS USED FOR CHECKING THE STATUS OF A THREAD. IT RETURNS TRUE IF THE THREAD IS DAEMON ELSE IT RETURNS FALSE.
SETDAEMON(): METHOD CAN ONLY BE CALLED BEFORE STARTING THE THREAD. THIS METHOD WOULD THROW ILLEGALTHREADSTATEEXCEPTION IF YOU CALL THIS METHOD AFTER THREAD.START() METHOD. (REFER THE EXAMPLE)
THREAD JOIN() METHOD
THE JOIN() METHOD IS USED TO HOLD THE EXECUTION OF CURRENTLY RUNNING THREAD UNTIL THE SPECIFIED THREAD IS DEAD(FINISHED EXECUTION).

DIFFERENCE BETWEEN CALLING RUN AND START METHOD
WE CAN CALL RUN() METHOD IF WE WANT BUT THEN IT WOULD BEHAVE JUST LIKE A NORMAL METHOD AND WE WOULD NOT BE ABLE TO TAKE THE ADVANTAGE OF MULTITHREADING. WHEN THE RUN METHOD GETS CALLED THOUGH START() METHOD THEN A NEW SEPARATE THREAD IS BEING ALLOCATED TO THE EXECUTION OF RUN METHOD, SO IF MORE THAN ONE THREAD CALLS START() METHOD THAT MEANS THEIR RUN METHOD IS BEING EXECUTED BY SEPARATE THREADS (THESE THREADS RUN SIMULTANEOUSLY).
ON THE OTHER HAND IF THE RUN() METHOD OF THESE THREADS ARE BEING CALLED DIRECTLY THEN THE EXECUTION OF ALL OF THEM IS BEING HANDLED BY THE SAME CURRENT THREAD AND NO MULTITHREADING WILL TAKE PLACE, HENCE THE OUTPUT WOULD REFLECT THE SEQUENTIAL EXECUTION OF THREADS IN THE SPECIFIED ORDER.



CONCURRENCY (PARRELLAL COMPUTING) IN JAVA
-----------------------------------------






MULTITHREADING AND PARALLEL COMPUTATION IN JAVA @ HOLCZER BALAZS


-------------------------------------------------------------
-------------------------------------------------------------
JAVA PARALLELISM SPECIALIZATION IN COURSERA - RICE UNIVERSITY
-------------------------------------------------------------

PARALLEL PROGRAMMING IN JAVA - COURSERA/ RICE UNIVERSITY 

CONCURRENT PROGRAMMING IN JAVA - COURSERA/ RICE UNIVERSITY 

DISTRIBUTED PROGRAMMING IN JAVA - COURSERA/ RICE UNIVERSITY 
-------------------------------------------------------------



CORE JAVA CONCURRENCY <HTTPS://DZONE.COM/REFCARDZ/CORE-JAVA-CONCURRENCY>

JAVA / CONCURRENCY <HTTP://TUTORIALS.JENKOV.COM/JAVA-CONCURRENCY/JAVA-MEMORY-MODEL. L>







